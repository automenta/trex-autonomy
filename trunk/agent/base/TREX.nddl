
// Declare enumeration for Token States
enum TokenStates {INACTIVE, ACTIVE, MERGED, REJECTED}


// Declare built in constraints used for common TREX use cases

constraint default(var, value) { var <: numeric && value <: numeric }
constraint defaultOnCommit(var, value) { var <: numeric && value <: numeric }
constraint assertCompleted(s) { s <: TokenStates }
constraint assertRejected(s) { s <: TokenStates }


// Declare a marker class to indicate the base class should be a Timeline
// which enforces a total order. This should only arise where we
// have predicates!
class Timeline {}

/**
 * This global constant will be set when a deliberative reactor is loaded
 */
int missionEnd;

enum Mode {
  External, 	// Synchronize observations.
  Internal, 	// Publish updates at the current tick
  Ignore	// Not synchronized at all
}

class AgentTimeline extends Timeline {
  Mode mode; // Indicate if an internal or external timeline
  string defaultPredicate; // Sets the default predicate value for filling out an emty timeline and resettting
  bool persistent; // Indicate if the current value can be discarded on a reset to recover

  /**
   * A predicate to reflect that the timeline is undefined. Used to fill gaps
   * where they occur.
   */
  predicate undefined{};

  /**
   * A predicate which is used to block any successor states for a timeline
   */
  predicate Terminated{concurrent(end, missionEnd);}

  AgentTimeline(Mode _mode){
    mode = _mode;
    defaultPredicate = "undefined";
    persistent = true;
  }

  AgentTimeline(Mode _mode, string _defaultPredicate){
    mode = _mode;
    defaultPredicate = _defaultPredicate;
    persistent = true;
  }

  AgentTimeline(Mode _mode, string _defaultPredicate, bool _persistent){
    mode = _mode;
    defaultPredicate = _defaultPredicate;
    persistent = _persistent;
  }
}

/**
 * Base class for actions. These will never be exchanged across reactors and are generated to
 * accomplisg goals. This is a construct of a deliberative reactor
 */
class AgentActions {
	AgentActions(){}
}

class StateVariable extends AgentTimeline{
 	predicate Holds{ eq(duration,1); }
 	StateVariable(Mode _mode){super(_mode);}
	StateVariable(Mode _mode, string _defaultPredicate){super(_mode, _defaultPredicate);}
}

/**
 * Encapsulate Behaviors that have a state of active or inactive
 */
class Behavior extends AgentTimeline {
  int max_duration; // The maximum duration allowed in the active state. Bounds behavior times

  predicate Inactive{
    bool aborted;
    bool preempted;
    defaultOnCommit(aborted, false);
    defaultOnCommit(preempted, false);
  }

  predicate Active{
    int dispatch_time; // The time at which the goal was dispatched
    int max_duration; // A duration bound
    int timeout; // Max time for behavior to be stuck internally
    bool timed_out; // True if max_duration == duration	
    testEQ(timed_out, duration, max_duration);
    precedes(dispatch_time, start); // This is a <= constraint
  }

  Behavior(Mode _mode){
    super(_mode, "Inactive", false);
    max_duration = +inf;
  }

  Behavior(Mode _mode, int max_duration_){
    super(_mode, "Inactive", false);
    max_duration = max_duration_;
  }
};

/**
 * All behaviors will oscillate between active and inactive
 */
Behavior::Inactive{
  precedes(start, missionEnd);
  // These semantics are that we want to check a constraint, but not drive planning. It would be much better
  // to have these more explicitly listed as constraints, that get applied accordingly. For example, as transition
  // constraints. This guard structure is a hack.
  if(end){
    meets(Active);
  }
}

Behavior::Active{
  // Parameter Constraints
  leq(duration, max_duration);

  // Constraint on successor state
  meets(Inactive);

  // All behaviors must deactivate before the end of the agent time window
  precedes(end, missionEnd);

 // If at the end, apply a default to the timeout flag so that it is not zero.
 // This ensures the flag is set even if a max duration bound is not imposed
 if(end){
   defaultOnCommit(timed_out, false);
 }
}