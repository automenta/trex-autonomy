
// Declare enumeration for Token States
enum TokenStates {INACTIVE, ACTIVE, MERGED, REJECTED}


// Declare built in constraints used for common TREX use cases
constraint default(var, value) { var <: value }
constraint defaultOnCommit(var, value) { var <: value }
constraint assertCompleted(s) { s <: TokenStates }
constraint assertRejected(s) { s <: TokenStates }


// Declare a marker class to indicate the base class should be a Timeline
// which enforces a total order. This should only arise where we
// have predicates!
class Timeline {}

/**
 * The TICK DURATION in seconds. It will be set when the deliberative reactor is loaded
 */
float TICK_DURATION;

/**
 * This MISSION_END will be set when a deliberative reactor is loaded. It is mapped to the agent horizon
 */
int MISSION_END;

/**
 * The AGENT_CLOCK will capture clock tick events for propagation purposes
 */
int AGENT_CLOCK;

enum Mode {
  External, 	// Synchronize observations and dispatch plans as goals
  Internal, 	// Publish updates at the current tick
  Ignore	// Not synchronized at all (can be deprecated?)
}

class AgentTimeline extends Timeline {
  Mode mode; // Indicate if an internal or external timeline
  string defaultPredicate; // Sets the default predicate value for filling out an emty timeline and resettting
  bool persistent; // Indicate if the current value can be discarded on a reset to recover

  /**
   * A predicate to reflect that the timeline is undefined. Used to fill gaps
   * where they occur.
   */
  predicate undefined{};

  /**
   * A predicate which is used to block any successor states for a timeline
   */
  predicate Terminated{concurrent(end, MISSION_END);}

  AgentTimeline(Mode _mode){
    mode = _mode;
    defaultPredicate = "undefined";
    persistent = true;
  }

  AgentTimeline(Mode _mode, string _defaultPredicate){
    mode = _mode;
    defaultPredicate = _defaultPredicate;
    persistent = true;
  }

  AgentTimeline(Mode _mode, string _defaultPredicate, bool _persistent){
    mode = _mode;
    defaultPredicate = _defaultPredicate;
    persistent = _persistent;
  }
};

/**
 * Base class for actions. These will never be exchanged across reactors and are generated to
 * accomplisg goals. This is a construct of a deliberative reactor
 */
class AgentActions {
  /**
   * This action supports a common idiom to indicate we want something to happen proactively.
   */
  predicate startEvent{eq(duration, 1);}

  AgentActions(){}
};

class StateVariable extends AgentTimeline{
 	predicate Holds{ eq(duration,1); }
 	StateVariable(Mode _mode){super(_mode);}
	StateVariable(Mode _mode, string _defaultPredicate){super(_mode, _defaultPredicate);}
};

enum ResultStatus {
  UNDEFINED,  // Used when the behavior becomes inactive in an undefined state, such as when rebooting
  SUCCESS,    // Indicates the behavior terminated, accomplsihing its goals. Or so it believes!
  ABORTED,    // Means the behavior aborted pursuit of its goal of its own volition
  PREEMPTED   // Means the behavior terminated on command from a client.
};

/**
 * Encapsulate Behaviors that have a state of active or inactive
 */
class Behavior extends AgentTimeline {

  predicate Inactive{
    ResultStatus status;
  }

  predicate Active{
    int dispatch_time; // The time at which the goal was dispatched
    int max_duration; // If duration exceeds this, the token should be preempted.
    precedes(dispatch_time, start); // This is a <= constraint, but we use explicit temporal construct instead.
    temporalDistance(start, [1, +inf], MISSION_END);
  }

  Behavior(Mode _mode){
    super(_mode, "Inactive", false);
  }
};

Behavior::Active{
  meets(Inactive _reserved_s);
}

Behavior::Inactive{
  defaultOnCommit(status, UNDEFINED);
}
