
// Declare enumeration for Token States
enum TokenStates {INACTIVE, ACTIVE, MERGED, REJECTED}


// Declare built in constraints used for common TREX use cases

constraint default(var, value) { var <: value }
constraint defaultOnCommit(var, value) { var <: value }
constraint assertCompleted(s) { s <: TokenStates }
constraint assertRejected(s) { s <: TokenStates }


// Declare a marker class to indicate the base class should be a Timeline
// which enforces a total order. This should only arise where we
// have predicates!
class Timeline {}

/**
 * This global constant will be set when a deliberative reactor is loaded
 */
int missionEnd;

enum Mode {
  External, 	// Synchronize observations.
  Internal, 	// Publish updates at the current tick
  Ignore	// Not synchronized at all
}

class AgentTimeline extends Timeline {
  Mode mode; // Indicate if an internal or external timeline
  string defaultPredicate; // Sets the default predicate value for filling out an emty timeline and resettting
  bool persistent; // Indicate if the current value can be discarded on a reset to recover

  /**
   * A predicate to reflect that the timeline is undefined. Used to fill gaps
   * where they occur.
   */
  predicate undefined{};

  /**
   * A predicate which is used to block any successor states for a timeline
   */
  predicate Terminated{concurrent(end, missionEnd);}

  AgentTimeline(Mode _mode){
    mode = _mode;
    defaultPredicate = "undefined";
    persistent = true;
  }

  AgentTimeline(Mode _mode, string _defaultPredicate){
    mode = _mode;
    defaultPredicate = _defaultPredicate;
    persistent = true;
  }

  AgentTimeline(Mode _mode, string _defaultPredicate, bool _persistent){
    mode = _mode;
    defaultPredicate = _defaultPredicate;
    persistent = _persistent;
  }
};

/**
 * Base class for actions. These will never be exchanged across reactors and are generated to
 * accomplisg goals. This is a construct of a deliberative reactor
 */
class AgentActions {
  /**
   * This action supports a common idiom to indicate we want something to happen proactively.
   */
  predicate startEvent{eq(duration, 1);}

  AgentActions(){}
};

class StateVariable extends AgentTimeline{
 	predicate Holds{ eq(duration,1); }
 	StateVariable(Mode _mode){super(_mode);}
	StateVariable(Mode _mode, string _defaultPredicate){super(_mode, _defaultPredicate);}
};

enum ResultStatus {
  UNDEFINED,  // Used when the behavior becomes inactive in an undefined state, such as when rebooting
  SUCCESS,    // Indicates the behavior terminated, accomplsihing its goals. Or so it believes!
  ABORTED,    // Means the behavior aborted pursuit of its goal of its own volition
  PREEMPTED   // Means the behavior terminated on command from a client.
};

/**
 * Encapsulate Behaviors that have a state of active or inactive
 */
class Behavior extends AgentTimeline {
  int max_duration; // The maximum duration allowed in the active state. Bounds behavior times

  predicate Inactive{
    ResultStatus status;
    defaultOnCommit(status, UNDEFINED);
  }

  predicate Active{
    int dispatch_time; // The time at which the goal was dispatched
    int max_duration; // A duration bound
    int timeout; // Max time for behavior to be stuck internally
    bool timed_out; // True if max_duration == duration	
    ResultStatus status; 
    testEQ(timed_out, duration, max_duration);
    precedes(dispatch_time, start); // This is a <= constraint
    temporalDistance(start, [1, +inf], missionEnd);
  }

  Behavior(Mode _mode){
    super(_mode, "Inactive", false);
    max_duration = +inf;
  }

  Behavior(Mode _mode, int max_duration_){
    super(_mode, "Inactive", false);
    max_duration = max_duration_;
  }
};

Behavior::Active{
  // Constraint on successor state
  meets(Inactive _reserved_s);

 // If at the end, apply a default to the timeout flag so that it is not zero.
 // This ensures the flag is set even if a max duration bound is not imposed
 if(end){
   eq(status, _reserved_s.status);
   defaultOnCommit(timed_out, false);
 }
}
