#summary The Foundations of Constraint-based Plans, Planning and Plan Execution
<wiki:toc max_depth="2" />

= Timelines and Tokens =
Consider a spacecraft travelling through deep space, tasked with taking pictures of specific targets. The spacecraft has an _engine_ which can be fired to alter its pose. It also has a _camera_ which is turned off when not in use. If the camera was previously off, it can require some warm up period before being ready. The spacecraft _attitude_ is either pointing at a specifc target, thus having a steady pose, or transitioning from one pose to another. There are 3 state variables of interest in this spacecraft scenario: *Engine*, *Camera*, and *Attitude*.  A _timeline_ captures the values of a state variable over time. The figure below illustrates timelines for each of the above state variables. Both the *Camera* and the *Engine* are _Off_ and the spacecraft is _PointingAt_ a target given by _D12_. The value of a state variable, specified with a _Token_, has temporal extent, which means it persists for some period of time. The temporal scope for a value is bounded by a start and end time. In the figure below, the start time of each token  is fixed, but the end time is not. This indicates uncertainty and/or ambivalence about when the current value will end. A _token_ includes a _predicate_ with a possibly empty set of parameters, in keeping with conventional [http://en.wikipedia.org/wiki/First-order_logic first-order logic] representations. The *Engine* can be _Off_ or it can be _Thrusting_ to a target pose. The *Camera* can be _Off_, _WarmingUp_, _Ready_, or _TakingPicture_ at some target pose. The spaceacraft *Attitude* is either _PointingAt_ a target pose, or _TurningTo_ a target pose.

[http://trex-autonomy.googlecode.com/svn/wiki/images/initial_state.png]
 

= Constraints =
Suppose the spacecraft should take a picture of a specific asteroid. While it is taking a picture of the asteroid, it should be pointing at it. This can be said for any target pose. Also, in order to prevent jitter in the image, it is critical that the engine is _Off_ while the shot is being taken. The figure below illustrates how the spacecraft timelines are filled out to accomodate this goal. It illustrates the values of timelines as they are expected to change, as well as the constraints between start times, end times and parameters. _Causal Links_ form a chain connecting goals to initial conditions. A _causal link_ is a directed edge from a _master token_ to a _slave token_. The root of the causal graph is the _TakePicture_ token.

[http://trex-autonomy.googlecode.com/svn/wiki/images/partial_plan.png]

Note that the requirement that _while taking a picture, the engine must be off_ is expressed as a constraint from the *Camera* timeline to the *Engine* timeline, with precedence constraints between timepoints capturing the _while_ semantics. Also note the transition of the *Camera* timeline from _Off_ to _TakingPicture_ must go through intermediate states to first warm up and then be ready. The goal also requires a change in vehicle attitude. The adjustment in attitude is co-temporal with thrusting the engine. This is expressed by equality constraints beteen the start and end times of the respective tokens.

= Modeling =
So far we have used informal language to describe the spacecraft domain. [http://code.google.com/p/europa-pso/wiki/NDDLReference NDDL] is a formal modeling language used to specify a planning domain such that algorithms for search and inference can be applied to automatically fill out timelines as just described. 
== Class Declarations ==
A *Target* is a structure defining a point in cartesion space:
{{{
class Target{
 float x;
 float y;
 float z;

 Target(float _x, _y, _z){
  x = _x;
  y = _y;
  z = _z;
 }
}
}}}
The *Engine* timeline is declared thus:
{{{
class Engine extends Timeline{
 predicate Off{}
 predicate Thrusting{
  Target target;
 }

 Engine(){super();}
}
}}}

Similarly, we can declare *Attitude* and *Camera* timelines.
{{{
class Camera extends Timeline {
 predicate Off{}
 predicate WarmingUp{}
 predicate Ready{}
 predicate TakingPicture{
  Target target;
 }
 Camera(){super();}
}

class Attitude extends Timeline {
 predicate PointingAt{
  Target target;
 }
 predicate TurningTo{
  Target target;
 }

 Attitude(){super();}
}
}}}
== Transition Constraints ==
There are a number of constraints governing transitions within a given timeline. For example, the engine will transition between _Off_ and _Thrusting_. We can express this with rules constraining successor and predecessor values of each value:
{{{
Engine::Off{
 meets(Thrusting);
 met_by(Thrusting);
}
Engine::Thrusting{
 meets(Off);
 met_by(Off);
}
}}}
*Meets* and *met_by* are examples of qualitative constraints between temporal intervals known as [http://code.google.com/p/europa-pso/wiki/NDDLReference#Slave_Allocation_and_Temporal_Relations Allen Relations]. If the *Camera* is _Off_ it's next state will always be _WarmingUp_:
{{{
Camera::Off{
 meets(WarmingUp);
}
}}}
Similarly, if it is _WarmingUp_, it will transition into _Ready_, and it it's prior value must be _Off_.
{{{
Camera::WarmingUp{
 meets(Ready);
 met_by(Off);
}
}}}
The Attitude state variable is also constrained to transition between PointingAt and TurningTo. In this case, we have to introduce a constraint between parameters of tokens:
{{{
Attitude::PointingAt{
 meets(TurningTo);
 // There is a parameter constraint equating parameters of the current and previous values.
 met_by(TurningTo pred);
 pred.target == target;
}
Attitude::TurningTo{
 meets(PointingAt succ);
 target == succ.target;
 met_by(PointingAt);
}
}}}
== Interaction Constraints ==
In addition to constraints on transitions within a timeline, we described a number of constraints between values across timelines. For example, the constraints holding on _TakingPicture_ additionally include:
{{{
Camera::TakingPicture{
 contained_by(Engine.Off);
 contained_by(Attitude.PointingAt p);
 p.target == target;
}
}}}
Also, the interaction between _Attitude.TuringTo_ and _Engine.Thrusting_ can be stated simply:
{{{
Attitude::TurningTo{
 equals(Engine.Thrusting t);
 t.target == target;
}
}}}
= Automated Planning =
== Flaws ==

|| This is a really long sentence that could be wrapped. || [http://trex-autonomy.googlecode.com/svn/wiki/images/fix_flaws.png] ||

== Plan Refinement ==
|| [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.0.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.1.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.2.png] ||
|| [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.3.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.4.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.5.png] ||
|| [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.6.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.7.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.8.png] ||
|| [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.9.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.10.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.11.png] ||
|| [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.12.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.13.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.14.png] ||
|| [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.15.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.16.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.17.png] ||





