#summary The Foundations of Constraint-based Plans, Planning and Plan Execution
<wiki:toc max_depth="2" />

= Timelines and Tokens =
Consider a spacecraft travelling through deep space, tasked with taking pictures of specific targets. The spacecraft has an _engine_ which can be fired to alter its pose. It also has a _camera_ which is turned off when not in use. If the camera was previously off, it can require some warm up period before being ready. The spacecraft _attitude_ is either pointing at a specifc target, thus having a steady pose, or transitioning from one pose to another. There are 3 state variables of interest in this spacecraft scenario: *Engine*, *Camera*, and *Attitude*.  A _timeline_ captures the values of a state variable over time. The figure below illustrates timelines for each of the above state variables. Both the *Camera* and the *Engine* are _Off_ and the spacecraft is _PointingAt_ a target given by _D12_. The value of a state variable, specified with a _Token_, has temporal extent, which means it persists for some period of time. The temporal scope for a value is bounded by a start and end time. In the figure below, the start time of each token  is fixed, but the end time is not. This indicates uncertainty and/or ambivalence about when the current value will end. A _token_ includes a _predicate_ with a possibly empty set of parameters, in keeping with conventional [http://en.wikipedia.org/wiki/First-order_logic first-order logic] representations. The *Engine* can be _Off_ or it can be _Thrusting_ to a target pose. The *Camera* can be _Off_, _WarmingUp_, _Ready_, or _TakingPicture_ at some target pose. The spaceacraft *Attitude* is either _PointingAt_ a target pose, or _TurningTo_ a target pose.

[http://trex-autonomy.googlecode.com/svn/wiki/images/initial_state.png]
 

= Constraints and Causal Links =
Suppose the spacecraft should take a picture of a specific asteroid. While it is taking a picture of the asteroid, it should be pointing at it. This can be said for any target pose. Also, in order to prevent jitter in the image, it is critical that the engine is _Off_ while the shot is being taken. The figure below illustrates how the spacecraft timelines are filled out to accomodate this goal. It illustrates the values of timelines as they are expected to change, as well as the constraints between start times, end times and parameters. _Causal Links_ form a chain connecting goals to initial conditions. A _causal link_ is a directed edge from a _master token_ to a _slave token_. The root of the causal graph is the _TakePicture_ token.

[http://trex-autonomy.googlecode.com/svn/wiki/images/partial_plan.png]

Note that the requirement that _while taking a picture, the engine must be off_ is expressed as a constraint from the *Camera* timeline to the *Engine* timeline, with precedence constraints between timepoints capturing the _while_ semantics. Also note the transition of the *Camera* timeline from _Off_ to _TakingPicture_ must go through intermediate states to first warm up and then be ready. The goal also requires a change in vehicle attitude. The adjustment in attitude is co-temporal with thrusting the engine. This is expressed by equality constraints beteen the start and end times of the respective tokens.

= Modeling =
So far we have used informal language to describe the spacecraft domain. [http://code.google.com/p/europa-pso/wiki/NDDLReference NDDL] is a formal modeling language used to specify a planning domain such that algorithms for search and inference can be applied to automatically fill out timelines as just described. 
== Class Declarations ==
A *Target* is a structure defining a point in cartesion space:
{{{
class Target{
 float x;
 float y;
 float z;

 Target(float _x, _y, _z){
  x = _x;
  y = _y;
  z = _z;
 }
}
}}}
The *Engine* timeline is declared thus:
{{{
class Engine extends Timeline{
 predicate Off{}
 predicate Thrusting{
  Target target;
 }

 Engine(){super();}
}
}}}

Similarly, we can declare *Attitude* and *Camera* timelines.
{{{
class Camera extends Timeline {
 predicate Off{}
 predicate WarmingUp{}
 predicate Ready{}
 predicate TakingPicture{
  Target target;
 }
 Camera(){super();}
}

class Attitude extends Timeline {
 predicate PointingAt{
  Target target;
 }
 predicate TurningTo{
  Target target;
 }

 Attitude(){super();}
}
}}}
== Transition Constraints ==
There are a number of constraints governing transitions within a given timeline. For example, the engine will transition between _Off_ and _Thrusting_. We can express this with rules constraining successor and predecessor values of each value:
{{{
Engine::Off{
 meets(Thrusting);
 met_by(Thrusting);
}
Engine::Thrusting{
 meets(Off);
 met_by(Off);
}
}}}
*Meets* and *met_by* are examples of qualitative constraints between temporal intervals known as [http://code.google.com/p/europa-pso/wiki/NDDLReference#Slave_Allocation_and_Temporal_Relations Allen Relations]. If the *Camera* is _Off_ it's next state will always be _WarmingUp_:
{{{
Camera::Off{
 meets(WarmingUp);
}
}}}
Similarly, if it is _WarmingUp_, it will transition into _Ready_, and it it's prior value must be _Off_.
{{{
Camera::WarmingUp{
 meets(Ready);
 met_by(Off);
}
}}}
The Attitude state variable is also constrained to transition between PointingAt and TurningTo. In this case, we have to introduce a constraint between parameters of tokens:
{{{
Attitude::PointingAt{
 meets(TurningTo);
 // There is a parameter constraint equating parameters of the current and previous values.
 met_by(TurningTo pred);
 pred.target == target;
}
Attitude::TurningTo{
 meets(PointingAt succ);
 target == succ.target;
 met_by(PointingAt);
}
}}}
== Interaction Constraints ==
In addition to constraints on transitions within a timeline, we described a number of constraints between values across timelines. For example, the constraints holding on _TakingPicture_ additionally include:
{{{
Camera::TakingPicture{
 contained_by(Engine.Off);
 contained_by(Attitude.PointingAt p);
 p.target == target;
}
}}}
Also, the interaction between _Attitude.TuringTo_ and _Engine.Thrusting_ can be stated simply:
{{{
Attitude::TurningTo{
 equals(Engine.Thrusting t);
 t.target == target;
}
}}}
= Automated Planning =
There is a very general notion that a plan might be flawed, and thus require fixing. The primary reasons why a plan is flawed are because it is _incomplete_ or _inconsistent_. If a plan is _incomplete_, it can be further refined. If it is _inconsistent_ it can be repaired. This section will illustrate the process of plan refinement using the spacecraft example, whereby an initial state and goal represents an _partial plan_ which can be incrementally refined until completion. Plan repair will not be discussed at this time. Suffice to say, it requires a relaxation of the plan in some fashion.

|| [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.0.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.1.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.2.png] ||
|| The example begins with an initial state as previously described, and a goal to take a picture of the Asteroid. In this case, the goal represents a flaw since no decision has been made to put it in the plan. This is indicated by the yellow color and is called an _open condition_. The grey tokens indicate slaves entailed by the model. However, they are not considered flaws because their respective masters can continue indefinitely and thus no transition is actually required. In this case they are just constraints that any plan must not contradict, rather than states that must be achieved.|| There is only one option available to resolve this first flaw - it must be _activated_. Activation means that the token exists as a new state transition in the plan. Alternatively one might be able to merge an open-condition with a pre-existing token in the plan. We will see examples of that later. Once a token has been _activated_ we color it blue. The model is applied to _active_ tokens, generating slave tokens which are also flaws. Observe that the _TakingPicture_ token has not been inserted  in the timeline yet. || A Timeline is like a unary resource in that there can be at most one value at a time.  Hence the plan is not complete until the token has been ordered with respect to other tokens on the same timeline. We call this ordering requirement a _threat_ since the potential overlap of unordered tokens on a timeline threatens the safe execution of the plan. The flaw is resolved by inserting the token after the initial value. Observe a side-effect of this insertion - the previously ignored slave of the _Camera.Off_ token is now considered a flaw. Why is this? Because the plan now requires the camera to transition out of the _Off_ state, and thus the _start time_ for the successor token is in the planning time horizon and must be dealt with in order to prove the plan complete.||
|| [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.3.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.4.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.5.png] ||
|| [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.6.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.7.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.8.png] ||
|| [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.9.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.10.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.11.png] ||
|| [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.12.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.13.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.14.png] ||
|| [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.15.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.16.png] || [http://trex-autonomy.googlecode.com/svn/wiki/images/plan.17.png] ||





